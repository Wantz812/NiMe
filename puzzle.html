<!DOCTYPE html>
<html lang="az">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Puzzle Arena üß©</title>

  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@600;700&family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --accent: #ff4d9d;

      --bg0: #070A12;
      --bg1: #0B1022;

      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.72);
      --muted2: rgba(255,255,255,.56);

      --cardA: rgba(255,255,255,.10);
      --cardB: rgba(255,255,255,.06);

      --stroke: rgba(255,255,255,.12);
      --stroke2: rgba(255,255,255,.18);

      --shadow: 0 16px 50px rgba(0,0,0,.30);
      --shadow2: 0 22px 80px rgba(0,0,0,.44);

      --blur: blur(18px);

      --meshA: rgba(255,77,157,.22);
      --meshB: rgba(61,123,253,.18);
      --meshC: rgba(47,191,113,.16);
      --meshD: rgba(255,214,10,.10);

      --safeTop: env(safe-area-inset-top, 0px);
      --safeBottom: env(safe-area-inset-bottom, 0px);

      --board: min(460px, 92vw);
      --gap: 7px;
      --tileRadius: 16px;
    }

    *{ box-sizing: border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: Poppins, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      background:
        radial-gradient(1100px 800px at 18% 16%, var(--meshA), transparent 55%),
        radial-gradient(900px 700px at 86% 20%, var(--meshB), transparent 58%),
        radial-gradient(900px 650px at 75% 92%, var(--meshC), transparent 60%),
        radial-gradient(700px 600px at 22% 90%, var(--meshD), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
    }

    /* Aurora */
    .aurora{
      position: fixed;
      inset:-30vh -20vw;
      pointer-events:none;
      z-index:0;
      opacity:.58;
      filter: blur(22px) saturate(1.1);
      mix-blend-mode: screen;
    }
    .aurora::before, .aurora::after{
      content:"";
      position:absolute;
      inset:0;
      background:
        conic-gradient(from 180deg at 40% 40%,
          rgba(255,77,157,0),
          rgba(255,77,157,.34),
          rgba(50,173,230,.24),
          rgba(52,199,89,.18),
          rgba(255,214,10,.14),
          rgba(255,77,157,.28),
          rgba(255,77,157,0)
        );
      animation: spin 28s linear infinite;
      transform-origin: 40% 40%;
    }
    .aurora::after{
      inset: 10% 15%;
      opacity:.58;
      animation-duration: 36s;
      transform-origin: 60% 60%;
    }
    @keyframes spin{ to{ transform: rotate(360deg);} }

    /* Grain */
    .grain{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:1;
      opacity:.12;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='https://www.w3.org/2000/svg' width='160' height='160'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.85' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='160' height='160' filter='url(%23n)' opacity='.55'/%3E%3C/svg%3E");
      mix-blend-mode: overlay;
    }

    /* Toast */
    .toast{
      position:fixed;
      left:50%;
      bottom: calc(18px + var(--safeBottom));
      transform:translateX(-50%);
      padding: 11px 14px;
      border-radius: 999px;
      font-weight:900;
      opacity:0;
      pointer-events:none;
      transition: .22s ease;
      z-index:999;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.55);
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
      box-shadow: 0 20px 70px rgba(0,0,0,.45);
      color: rgba(255,255,255,.92);
      max-width: min(92vw, 560px);
      text-align:center;
    }
    .toast.show{opacity:1; transform:translateX(-50%) translateY(-4px);}

    /* Nav (index vibe) */
    .nav-bar{
      position: sticky;
      top: calc(10px + var(--safeTop));
      z-index: 50;
      max-width: 1060px;
      margin: 14px auto 16px;
      padding: 12px 14px;
      border-radius: 22px;
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, var(--cardA), var(--cardB));
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
      box-shadow: var(--shadow);
      display:grid;
      grid-template-columns: 1.2fr .9fr 1.4fr;
      align-items:center;
      gap: 12px;
    }
    .brand{display:flex;align-items:center;gap:12px;min-width:0}
    .brand-mark{
      width:42px;height:42px;border-radius:14px;
      display:grid;place-items:center;
      background: linear-gradient(135deg, rgba(255,255,255,.18), rgba(255,255,255,.06));
      border: 1px solid rgba(255,255,255,.22);
      box-shadow: 0 18px 44px rgba(0,0,0,.22);
    }
    .brand-text{
      font-family:'Dancing Script',cursive;
      font-size: 1.55rem;
      line-height: 1;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .mini-chip{
      margin-top: 4px;
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: var(--muted);
      font-size: .84rem;
      width: fit-content;
      font-weight: 800;
    }
    .nav-center{display:flex;justify-content:center}
    .nav-actions{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end}
    .nav-link{
      padding: 9px 12px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.90);
      font-size:.86rem;
      text-decoration:none;
      display:inline-flex;
      align-items:center;
      gap: 8px;
      transition: transform .16s ease, background .16s ease, box-shadow .16s ease;
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
    }
    .nav-link:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.10);
      box-shadow: 0 14px 30px rgba(0,0,0,.22);
    }
    .back-pill{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding: 10px 14px;
      border-radius: 999px;
      font-weight: 900;
      text-decoration:none;
      color: rgba(255,255,255,.95);
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.35);
      box-shadow: 0 20px 65px rgba(0,0,0,.35);
      transition: transform .16s ease, filter .16s ease;
    }
    .back-pill:hover{ transform: translateY(-1px); filter: brightness(1.05); }
    .back-pill:active{ transform: translateY(0) scale(.99); }

    /* Layout */
    .container{
      position: relative;
      z-index: 4;
      max-width: 1060px;
      margin: 0 auto;
      padding: 12px 18px calc(90px + var(--safeBottom));
    }
    .hero{
      border-radius: 26px;
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, var(--cardA), var(--cardB));
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
      box-shadow: var(--shadow);
      padding: 18px;
      overflow:hidden;
      position: relative;
      margin-bottom: 14px;
    }
    .hero::before{
      content:"";
      position:absolute;
      inset:-2px;
      background:
        radial-gradient(700px 360px at 20% 0%, rgba(255,77,157,.16), transparent 65%),
        radial-gradient(620px 360px at 90% 10%, rgba(61,123,253,.12), transparent 60%);
      pointer-events:none;
    }
    .hero > *{ position: relative; z-index: 1; }
    .kicker{
      display:flex; align-items:center; gap:10px;
      color: var(--muted);
      font-weight: 900;
      font-size: .9rem;
    }
    .dot{
      width:10px;height:10px;border-radius:999px;background: var(--accent);
      box-shadow: 0 0 22px rgba(255,77,157,.35);
    }
    h1{
      margin: 8px 0 6px;
      font-family:'Dancing Script',cursive;
      font-size: 2.6rem;
      letter-spacing: -.2px;
    }
    .lead{
      margin: 0 0 10px;
      color: var(--muted);
      line-height: 1.65;
      font-weight: 650;
    }
    .chips{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 10px;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: rgba(255,255,255,.88);
      font-weight: 900;
      font-size: .88rem;
    }
    .chip b{ color: #fff; }

    .grid2{
      display:grid;
      grid-template-columns: 1fr 1.2fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .nav-bar{ grid-template-columns: 1fr; }
      .nav-center{ justify-content:flex-start; }
      .nav-actions{ justify-content:flex-start; }
      .grid2{ grid-template-columns: 1fr; }
    }

    .panel{
      border-radius: 26px;
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, var(--cardA), var(--cardB));
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
      box-shadow: var(--shadow);
      padding: 16px;
      overflow:hidden;
      position: relative;
    }
    .panel::before{
      content:"";
      position:absolute;
      inset:-2px;
      background:
        radial-gradient(560px 320px at 10% 10%, rgba(255,77,157,.12), transparent 62%),
        radial-gradient(560px 320px at 90% 0%, rgba(61,123,253,.10), transparent 62%);
      pointer-events:none;
      opacity:.9;
    }
    .panel > *{ position:relative; z-index:1; }

    .h2{
      font-weight: 950;
      font-size: 1.08rem;
      margin: 0 0 8px;
      letter-spacing: -.1px;
    }
    .note{
      margin: 0 0 12px;
      color: var(--muted);
      line-height: 1.65;
      font-weight: 650;
    }

    .row{ display:flex; gap: 10px; flex-wrap:wrap; align-items:center; }
    .row + .row{ margin-top: 10px; }

    .btn{
      appearance: none;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.94);
      padding: 10px 12px;
      border-radius: 14px;
      font-weight: 900;
      cursor: pointer;
      transition: transform .16s ease, filter .16s ease, background .16s ease, box-shadow .16s ease;
      user-select:none;
    }
    .btn:hover{ transform: translateY(-1px); background: rgba(255,255,255,.10); box-shadow: 0 14px 30px rgba(0,0,0,.22); }
    .btn:active{ transform: translateY(0) scale(.99); }
    .btn.primary{
      border: 1px solid rgba(255,255,255,.14);
      background: linear-gradient(135deg, rgba(255,77,157,.86), rgba(255,214,10,.60));
      box-shadow: 0 18px 55px rgba(0,0,0,.24);
    }
    .btn.primary:hover{ filter: brightness(1.05); }
    .btn.danger{
      background: rgba(255,59,48,.16);
      border-color: rgba(255,59,48,.25);
    }
    .btn.ghost{
      background: rgba(0,0,0,.28);
      border-color: rgba(255,255,255,.12);
    }

    .seg{
      display:flex;
      gap: 8px;
      padding: 6px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.20);
      width: fit-content;
    }
    .seg button{
      padding: 9px 12px;
      border-radius: 12px;
      border: 1px solid transparent;
      background: transparent;
      color: rgba(255,255,255,.86);
      font-weight: 950;
      cursor:pointer;
      transition: .16s ease;
    }
    .seg button.active{
      background: rgba(255,255,255,.10);
      border-color: rgba(255,255,255,.14);
      color: #fff;
      box-shadow: 0 12px 26px rgba(0,0,0,.18);
    }

    .select, .input{
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: rgba(255,255,255,.92);
      outline:none;
      font-weight: 850;
      min-width: 160px;
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
    }
    .input{ width: min(520px, 100%); }

    .toggle{
      display:inline-flex; align-items:center; gap:10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      font-weight: 950;
      cursor:pointer;
      user-select:none;
    }
    .toggle i{
      width: 18px; height: 18px; border-radius: 6px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.08);
      display:inline-block;
      position: relative;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.22);
    }
    .toggle.on i{
      background: rgba(47,191,113,.28);
      border-color: rgba(47,191,113,.35);
    }
    .toggle.on i::after{
      content:"";
      position:absolute; inset: 3px;
      border-radius: 5px;
      background: rgba(47,191,113,.85);
      box-shadow: 0 0 14px rgba(47,191,113,.20);
    }

    /* Board */
    .board-wrap{
      display:flex;
      flex-direction:column;
      gap: 12px;
      align-items:center;
    }
    .board{
      width: var(--board);
      height: var(--board);
      border-radius: 26px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      box-shadow: var(--shadow2);
      padding: 12px;
      position: relative;
      overflow:hidden;
    }
    .board::before{
      content:"";
      position:absolute;
      inset:-2px;
      background:
        radial-gradient(520px 340px at 22% 10%, rgba(255,77,157,.12), transparent 62%),
        radial-gradient(520px 340px at 86% 10%, rgba(61,123,253,.10), transparent 62%);
      opacity:.85;
      pointer-events:none;
    }

    .grid{
      position: relative;
      z-index: 2;
      width: 100%;
      height: 100%;
      display:grid;
      gap: var(--gap);
      touch-action: pan-x pan-y; /* allow custom swipe handling */
      user-select:none;
    }

    .tile{
      border-radius: var(--tileRadius);
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      overflow:hidden;
      position: relative;
      cursor: pointer;
      transform: translateZ(0);
      transition: transform .14s ease, box-shadow .14s ease, filter .14s ease;
    }
    .tile:hover{ transform: translateY(-1px); box-shadow: 0 18px 40px rgba(0,0,0,.25); }
    .tile:active{ transform: translateY(0) scale(.99); }
    .tile.blank{
      cursor: default;
      background: rgba(0,0,0,.25);
      border-color: rgba(255,255,255,.08);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.25);
    }

    .tile .img{
      position:absolute;
      inset:0;
      background-repeat: no-repeat;
      background-size: 100% 100%;
      filter: saturate(1.05) contrast(1.02);
    }

    .tile .num{
      position:absolute;
      right: 8px;
      bottom: 8px;
      padding: 5px 8px;
      border-radius: 999px;
      font-weight: 950;
      font-size: .82rem;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.14);
      color: rgba(255,255,255,.90);
      opacity: 0;
      transform: translateY(2px);
      transition: .18s ease;
      pointer-events:none;
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
    }
    .tile.show-num .num{ opacity: 1; transform: translateY(0); }

    .tile.selected{
      border-color: rgba(255,255,255,.20);
      box-shadow: 0 0 0 2px rgba(255,255,255,.22), 0 24px 60px rgba(0,0,0,.30);
      z-index: 5;
    }

    .tile.correct::after{
      content:"‚úì";
      position:absolute;
      left: 10px;
      top: 10px;
      width: 28px;
      height: 28px;
      border-radius: 999px;
      display:grid;
      place-items:center;
      font-weight: 1000;
      font-size: .95rem;
      color: rgba(255,255,255,.95);
      background: rgba(47,191,113,.30);
      border: 1px solid rgba(47,191,113,.38);
      box-shadow: 0 0 20px rgba(47,191,113,.18);
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
    }

    .tile.locked{
      cursor: default;
      filter: saturate(.96);
      opacity: .96;
    }
    .tile.locked:hover{ transform:none; box-shadow:none; }

    .overlay{
      position:absolute;
      inset: 12px;
      border-radius: 22px;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.14);
      backdrop-filter: var(--blur);
      -webkit-backdrop-filter: var(--blur);
      box-shadow: 0 24px 90px rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding: 18px;
      z-index: 20;
    }
    .overlay.show{ display:flex; }
    .overlay h2{
      margin: 0 0 8px;
      font-family:'Dancing Script',cursive;
      font-size: 2.3rem;
    }
    .overlay p{
      margin: 0 0 14px;
      color: var(--muted);
      font-weight: 750;
      line-height: 1.6;
    }
    .overlay .score{
      display:flex;
      gap: 10px;
      justify-content:center;
      flex-wrap:wrap;
      margin-bottom: 14px;
    }

    .mini{
      padding: 9px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight: 950;
      color: rgba(255,255,255,.92);
    }

    .preview{
      width: 100%;
      display:flex;
      gap: 12px;
      align-items:center;
      margin-top: 10px;
    }
    .preview img{
      width: 86px;
      height: 86px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.14);
      object-fit: cover;
      box-shadow: 0 18px 55px rgba(0,0,0,.25);
    }
    .preview .txt{
      min-width:0;
      color: var(--muted);
      line-height: 1.55;
      font-weight: 650;
    }

    .hr{
      height: 1px;
      background: rgba(255,255,255,.10);
      margin: 12px 0;
    }

    /* Confetti canvas */
    #confettiCanvas{
      position: fixed;
      inset:0;
      pointer-events:none;
      z-index: 999;
    }

    /* Small helper */
    .kbd{
      font-weight: 1000;
      padding: 2px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: rgba(255,255,255,.90);
      font-size: .86rem;
    }
  </style>
</head>

<body>
  <div class="aurora" aria-hidden="true"></div>
  <div class="grain" aria-hidden="true"></div>
  <canvas id="confettiCanvas"></canvas>
  <div class="toast" id="toast">‚úÖ</div>

  <div class="nav-bar">
    <div class="brand">
      <div class="brand-mark">üß©</div>
      <div>
        <div class="brand-text">M & N | Puzzle</div>
        <div class="mini-chip">∆èyl…ônc…ô rejimi: ON ‚ú®</div>
      </div>
    </div>

    <div class="nav-center">
      <a class="back-pill" href="index.html">‚¨Ö Geri</a>
    </div>

    <div class="nav-actions">
      <a class="nav-link" href="gift.html">üéÅ GIFT</a>
      <a class="nav-link" href="game.html">üéÆ Mini Oyunlar</a>
      <a class="nav-link" href="memories.html">üñºÔ∏è Xatir…ôl…ôr</a>
    </div>
  </div>

  <div class="container">
    <section class="hero">
      <div class="kicker"><span class="dot"></span> Puzzle Arena ‚Äî ‚Äú√ßox eyl…ônc…ôli‚Äù versiya</div>
      <h1>Par√ßalar yerini tapsƒ±n üíò</h1>
      <p class="lead">
        <b>Slide</b> rejimind…ô klassik s√ºr√º≈üd√ºrm…ô puzzle; <b>Swap</b> rejimind…ô is…ô ist…ônil…ôn iki hiss…ôni d…ôyi≈üirs…ôn.
        Telefonla da super rahatdƒ±r: s√ºr√º≈üd√ºr, klikl…ô, bitir ‚ú®
      </p>
      <div class="chips">
        <div class="chip">üïí Vaxt: <b id="timeChip">00:00</b></div>
        <div class="chip">üß† H…ôr…ôk…ôt: <b id="moveChip">0</b></div>
        <div class="chip">üéØ Rejim: <b id="modeChip">Slide</b></div>
        <div class="chip">üß© √ñl√ß√º: <b id="sizeChip">4√ó4</b></div>
      </div>
    </section>

    <div class="grid2">
      <section class="panel">
        <div class="h2">Kontrol Paneli</div>
        <p class="note">ƒ∞pucu: Slide-da klaviatura il…ô d…ô oynaya bil…ôrs…ôn: <span class="kbd">‚Üê</span> <span class="kbd">‚Üí</span> <span class="kbd">‚Üë</span> <span class="kbd">‚Üì</span></p>

        <div class="row">
          <div class="seg" role="tablist" aria-label="Puzzle Mode">
            <button id="modeSlideBtn" class="active" type="button">Slide üßä</button>
            <button id="modeSwapBtn" type="button">Swap üîÅ</button>
          </div>

          <select id="sizeSelect" class="select" title="√ñl√ß√º se√ß">
            <option value="3">3√ó3 (asan)</option>
            <option value="4" selected>4√ó4 (orta)</option>
            <option value="5">5√ó5 (√ß…ôtin)</option>
          </select>
        </div>

        <div class="row">
          <button class="btn primary" id="shuffleBtn" type="button">üîÄ Qarƒ±≈üdƒ±r</button>
          <button class="btn" id="hintBtn" type="button">üëÄ Hint (r…ôq…ôml…ôr)</button>
          <button class="btn ghost" id="previewBtn" type="button">üñºÔ∏è Preview</button>
        </div>

        <div class="row">
          <div class="toggle" id="lockToggle" title="Swap rejimind…ô d√ºz d√º≈ü…ôn hiss…ôl…ôri kilidl…ô">
            <i></i><span>Swap-da kilidl…ô</span>
          </div>
          <button class="btn danger" id="resetBestBtn" type="button">üßº Rekordlarƒ± sƒ±fƒ±rla</button>
        </div>

        <div class="hr"></div>

        <div class="h2">≈û…ôkil (ist…ôs…ôn d…ôyi≈ü)</div>
        <p class="note">Linki yapƒ±≈üdƒ±r ‚Üí ‚ÄúT…ôtbiq et‚Äù ‚Üí puzzle avtomatik yenil…ôn…ôc…ôk.</p>

        <div class="row" style="width:100%;">
          <input class="input" id="imgUrlInput" placeholder="≈û…ôkil linki (https://...jpg/png)" />
          <button class="btn" id="applyImgBtn" type="button">‚úÖ T…ôtbiq et</button>
        </div>

        <div class="preview" id="previewWrap" style="display:none;">
          <img id="previewImg" alt="Preview">
          <div class="txt">
            <b style="color:#fff;">Pro tip:</b> ≈û…ôkil √ßox ‚Äúqarƒ±≈üƒ±q‚Äù olanda 5√ó5 √ß…ôtin olur üòÑ
            <div style="margin-top:6px;color:var(--muted2);">Rejim + √∂l√ß√º d…ôyi≈ü…ônd…ô rekordlar ayrƒ± saxlanƒ±r.</div>
          </div>
        </div>

        <div class="hr"></div>

        <div class="h2">Rekordlar</div>
        <div class="row" style="align-items:stretch;">
          <div class="chip" style="background:rgba(0,0,0,.22); border-color:rgba(255,255,255,.14);">
            üèÜ Best Time: <b id="bestTime">‚Äî</b>
          </div>
          <div class="chip" style="background:rgba(0,0,0,.22); border-color:rgba(255,255,255,.14);">
            üöÄ Best Moves: <b id="bestMoves">‚Äî</b>
          </div>
        </div>

        <p class="note" style="margin-top:10px;">
          Slide: <b>qarƒ±≈üdƒ±rma h…ômi≈ü…ô solvable-dir</b> (random valid move-larla). Swap: ‚Äúd√ºz d√º≈ü…ôn‚Äù hiss…ôl…ôr…ô ‚úì g…ôlir.
        </p>
      </section>

      <section class="panel">
        <div class="board-wrap">
          <div class="h2" style="align-self:flex-start;">Puzzle Board</div>

          <div class="board" id="board">
            <div class="grid" id="grid" aria-label="Puzzle Grid"></div>

            <div class="overlay" id="winOverlay" role="dialog" aria-modal="true">
              <div>
                <h2 id="winTitle">AF∆èRƒ∞N ‚ù§Ô∏è</h2>
                <p id="winText">Hiss…ôl…ôr kimi, √ºr…ôkl…ôrimiz d…ô bir-birini tapdƒ± üíò</p>
                <div class="score">
                  <div class="mini">üïí <span id="winTime">00:00</span></div>
                  <div class="mini">üß† <span id="winMoves">0</span> h…ôr…ôk…ôt</div>
                  <div class="mini">üéØ <span id="winMode">Slide</span></div>
                </div>
                <div class="row" style="justify-content:center;">
                  <button class="btn primary" id="playAgainBtn" type="button">üîÄ Yenid…ôn oyna</button>
                  <button class="btn ghost" id="closeWinBtn" type="button">‚úã Baƒüla</button>
                </div>
              </div>
            </div>
          </div>

          <div class="note" style="text-align:center;">
            Mobil: barmaƒüƒ±nla <b>s√ºr√º≈üd√ºr</b> (Slide) ‚Ä¢ Swap: 2 hiss…ôni se√ß ‚Üí d…ôyi≈ü.
          </div>
        </div>
      </section>
    </div>
  </div>

  <script>
    /* =========================
       THEME (index il…ô uyƒüun)
    ========================== */
    const themes = {
      pink:  { accent:'#ff4d9d', bg0:'#070A12', bg1:'#0B1022', cardA:'rgba(255,255,255,.10)', cardB:'rgba(255,255,255,.06)', stroke:'rgba(255,255,255,.12)', stroke2:'rgba(255,255,255,.18)', meshA:'rgba(255,77,157,.24)', meshB:'rgba(61,123,253,.16)', meshC:'rgba(47,191,113,.14)', meshD:'rgba(255,214,10,.10)' },
      blue:  { accent:'#3d7bfd', bg0:'#060B16', bg1:'#07162B', cardA:'rgba(210,230,255,.12)', cardB:'rgba(210,230,255,.06)', stroke:'rgba(210,230,255,.16)', stroke2:'rgba(210,230,255,.22)', meshA:'rgba(61,123,253,.24)', meshB:'rgba(50,173,230,.18)', meshC:'rgba(47,191,113,.10)', meshD:'rgba(255,77,157,.08)' },
      green: { accent:'#2fbf71', bg0:'#06120C', bg1:'#071C12', cardA:'rgba(210,255,230,.12)', cardB:'rgba(210,255,230,.06)', stroke:'rgba(210,255,230,.16)', stroke2:'rgba(210,255,230,.22)', meshA:'rgba(47,191,113,.24)', meshB:'rgba(61,123,253,.12)', meshC:'rgba(255,214,10,.10)', meshD:'rgba(255,77,157,.08)' },
      night: { accent:'#ffb6c1', bg0:'#05030B', bg1:'#0B0622', cardA:'rgba(255,255,255,.09)', cardB:'rgba(255,255,255,.05)', stroke:'rgba(255,255,255,.11)', stroke2:'rgba(255,255,255,.18)', meshA:'rgba(255,182,193,.18)', meshB:'rgba(88,86,214,.16)', meshC:'rgba(50,173,230,.12)', meshD:'rgba(255,77,157,.08)' }
    };
    function applyTheme(name){
      const t = themes[name] || themes.pink;
      const root = document.documentElement;
      root.style.setProperty('--accent', t.accent);
      root.style.setProperty('--bg0', t.bg0);
      root.style.setProperty('--bg1', t.bg1);
      root.style.setProperty('--cardA', t.cardA);
      root.style.setProperty('--cardB', t.cardB);
      root.style.setProperty('--stroke', t.stroke);
      root.style.setProperty('--stroke2', t.stroke2);
      root.style.setProperty('--meshA', t.meshA);
      root.style.setProperty('--meshB', t.meshB);
      root.style.setProperty('--meshC', t.meshC);
      root.style.setProperty('--meshD', t.meshD);
    }
    applyTheme(localStorage.getItem('websiteTheme') || 'pink');

    /* =========================
       HELPERS
    ========================== */
    const $ = (sel) => document.querySelector(sel);
    const toast = $("#toast");
    let toastTimer = null;
    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add("show");
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=>toast.classList.remove("show"), 1200);
    }
    function pad2(n){ return String(n).padStart(2,'0'); }
    function formatTime(sec){
      const m = Math.floor(sec/60);
      const s = sec%60;
      return `${pad2(m)}:${pad2(s)}`;
    }

    /* =========================
       STATE
    ========================== */
    const DEFAULT_IMAGE_URL = "https://i.ibb.co/dwwzhbTH/Whats-App-mage-2025-12-08-at-10-16-21.jpg";
    let imageUrl = localStorage.getItem("puzzleImageUrl") || DEFAULT_IMAGE_URL;

    let mode = localStorage.getItem("puzzleMode") || "slide"; // slide | swap
    let size = parseInt(localStorage.getItem("puzzleSize") || "4", 10);
    if(![3,4,5].includes(size)) size = 4;

    let lockCorrect = localStorage.getItem("puzzleLockCorrect") === "true";

    // board arrays:
    // slide: numbers 1..n*n-1, 0 blank
    // swap:  0..n*n-1 (0 can be used as tile too, but we‚Äôll represent as 1..N, no blank)
    let tiles = [];
    let selectedIndex = null;

    let moves = 0;
    let seconds = 0;
    let timer = null;
    let started = false;

    /* =========================
       UI refs
    ========================== */
    const grid = $("#grid");
    const board = $("#board");
    const winOverlay = $("#winOverlay");
    const winTime = $("#winTime");
    const winMoves = $("#winMoves");
    const winMode = $("#winMode");
    const winTitle = $("#winTitle");
    const winText = $("#winText");

    const timeChip = $("#timeChip");
    const moveChip = $("#moveChip");
    const modeChip = $("#modeChip");
    const sizeChip = $("#sizeChip");

    const bestTimeEl = $("#bestTime");
    const bestMovesEl = $("#bestMoves");

    const sizeSelect = $("#sizeSelect");
    const modeSlideBtn = $("#modeSlideBtn");
    const modeSwapBtn = $("#modeSwapBtn");

    const shuffleBtn = $("#shuffleBtn");
    const hintBtn = $("#hintBtn");
    const previewBtn = $("#previewBtn");
    const previewWrap = $("#previewWrap");
    const previewImg = $("#previewImg");

    const imgUrlInput = $("#imgUrlInput");
    const applyImgBtn = $("#applyImgBtn");

    const lockToggle = $("#lockToggle");
    const resetBestBtn = $("#resetBestBtn");

    const playAgainBtn = $("#playAgainBtn");
    const closeWinBtn = $("#closeWinBtn");

    /* =========================
       RECORDS
    ========================== */
    function recKey(prefix){ return `puzzle_${prefix}_${mode}_${size}`; }
    function loadRecords(){
      const t = localStorage.getItem(recKey("bestTime"));
      const m = localStorage.getItem(recKey("bestMoves"));
      bestTimeEl.textContent = t ? formatTime(parseInt(t,10)) : "‚Äî";
      bestMovesEl.textContent = m ? String(parseInt(m,10)) : "‚Äî";
    }
    function saveRecordIfBest(){
      const tKey = recKey("bestTime");
      const mKey = recKey("bestMoves");

      const prevT = localStorage.getItem(tKey);
      const prevM = localStorage.getItem(mKey);

      let improved = false;

      if(!prevT || seconds < parseInt(prevT,10)){
        localStorage.setItem(tKey, String(seconds));
        improved = true;
      }
      if(!prevM || moves < parseInt(prevM,10)){
        localStorage.setItem(mKey, String(moves));
        improved = true;
      }
      loadRecords();
      return improved;
    }

    /* =========================
       TIMER
    ========================== */
    function resetRun(){
      moves = 0;
      seconds = 0;
      started = false;
      selectedIndex = null;
      if(timer){ clearInterval(timer); timer = null; }
      timeChip.textContent = "00:00";
      moveChip.textContent = "0";
    }
    function startTimerIfNeeded(){
      if(started) return;
      started = true;
      timer = setInterval(()=>{
        seconds++;
        timeChip.textContent = formatTime(seconds);
      }, 1000);
    }
    function incMoves(){
      moves++;
      moveChip.textContent = String(moves);
    }

    /* =========================
       PUZZLE BUILD
    ========================== */
    function setGridCss(){
      grid.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
      grid.style.gridTemplateRows = `repeat(${size}, 1fr)`;
      sizeChip.textContent = `${size}√ó${size}`;
      modeChip.textContent = (mode === "slide") ? "Slide" : "Swap";
    }

    function setModeUI(){
      modeSlideBtn.classList.toggle("active", mode === "slide");
      modeSwapBtn.classList.toggle("active", mode === "swap");
      lockToggle.style.display = (mode === "swap") ? "inline-flex" : "none";
      lockToggle.classList.toggle("on", lockCorrect);
      loadRecords();
      setGridCss();
    }

    function buildSolved(){
      tiles = [];
      const N = size*size;
      if(mode === "slide"){
        for(let i=1;i<=N-1;i++) tiles.push(i);
        tiles.push(0);
      } else {
        for(let i=1;i<=N;i++) tiles.push(i);
      }
    }

    function positionBg(tileNum){
      // tileNum 1..N (swap) or 1..N-1 (slide)
      // Calculate correct row/col based on solved order for image slicing
      const N = size*size;
      const idx = tileNum - 1; // 0-based in solved
      const row = Math.floor(idx / size);
      const col = idx % size;

      // Using px background-size for crispness
      const boardPx = grid.getBoundingClientRect().width || 400;
      const step = boardPx / size;

      return {
        bgSize: `${boardPx}px ${boardPx}px`,
        bgPos: `${-col*step}px ${-row*step}px`
      };
    }

    function tileIsCorrectAtIndex(tileNum, index){
      // correct tile number for that index:
      // swap: index 0 expects 1, etc.
      // slide: index 0 expects 1, ..., last expects 0(blank)
      if(mode === "swap"){
        return tileNum === (index+1);
      }
      // slide
      const N = size*size;
      if(index === N-1) return tileNum === 0;
      return tileNum === (index+1);
    }

    function render(){
      grid.innerHTML = "";

      const frag = document.createDocumentFragment();
      const N = size*size;

      for(let i=0;i<N;i++){
        const num = tiles[i];

        const tile = document.createElement("div");
        tile.className = "tile";
        tile.setAttribute("role", "button");
        tile.tabIndex = 0;
        tile.dataset.index = String(i);

        if(mode === "slide" && num === 0){
          tile.classList.add("blank");
          tile.setAttribute("aria-label", "Bo≈ü xana");
        } else {
          tile.setAttribute("aria-label", `Tile ${num}`);
          const img = document.createElement("div");
          img.className = "img";
          img.style.backgroundImage = `url('${imageUrl}')`;

          // Set background slice
          const b = positionBg(num);
          img.style.backgroundSize = b.bgSize;
          img.style.backgroundPosition = b.bgPos;

          tile.appendChild(img);

          const badge = document.createElement("div");
          badge.className = "num";
          badge.textContent = String(num);
          tile.appendChild(badge);

          if(tileIsCorrectAtIndex(num, i)) tile.classList.add("correct");
        }

        if(selectedIndex === i) tile.classList.add("selected");

        // lockCorrect only affects swap
        if(mode === "swap" && lockCorrect && tileIsCorrectAtIndex(num, i)){
          tile.classList.add("locked");
        }

        tile.addEventListener("click", ()=>onTileClick(i));
        tile.addEventListener("keydown", (e)=>{
          if(e.key === "Enter" || e.key === " "){
            e.preventDefault();
            onTileClick(i);
          }
        });

        frag.appendChild(tile);
      }

      grid.appendChild(frag);
    }

    /* =========================
       SHUFFLE (solvable)
    ========================== */
    function neighborsOfBlank(blankIdx){
      const r = Math.floor(blankIdx / size);
      const c = blankIdx % size;
      const n = [];
      if(r>0) n.push(blankIdx - size);
      if(r<size-1) n.push(blankIdx + size);
      if(c>0) n.push(blankIdx - 1);
      if(c<size-1) n.push(blankIdx + 1);
      return n;
    }

    function shuffleSlide(){
      // Do random valid moves from solved state -> guaranteed solvable
      buildSolved();
      const steps = Math.max(120, size*size*50);
      let blank = tiles.indexOf(0);
      let prev = -1;

      for(let s=0;s<steps;s++){
        const nb = neighborsOfBlank(blank).filter(x => x !== prev);
        const pick = nb[Math.floor(Math.random()*nb.length)];
        // swap blank with pick
        [tiles[blank], tiles[pick]] = [tiles[pick], tiles[blank]];
        prev = blank;
        blank = pick;
      }

      // avoid already solved
      if(isSolved()) shuffleSlide();
    }

    function shuffleSwap(){
      buildSolved();
      // Fisher-Yates
      for(let i=tiles.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
      }
      if(isSolved()) shuffleSwap();
    }

    function shufflePuzzle(){
      closeWin();
      resetRun();
      selectedIndex = null;

      if(mode === "slide") shuffleSlide();
      else shuffleSwap();

      render();
      showToast("üîÄ Qarƒ±≈üdƒ±rƒ±ldƒ±!");
    }

    /* =========================
       MOVE RULES
    ========================== */
    function canSlide(index){
      const blank = tiles.indexOf(0);
      const r1 = Math.floor(index/size), c1 = index%size;
      const r2 = Math.floor(blank/size), c2 = blank%size;
      const manhattan = Math.abs(r1-r2) + Math.abs(c1-c2);
      return manhattan === 1;
    }

    function slideMove(index){
      const blank = tiles.indexOf(0);
      if(!canSlide(index)) return false;
      [tiles[index], tiles[blank]] = [tiles[blank], tiles[index]];
      return true;
    }

    function swapMove(a,b){
      if(a === b) return false;
      // if lockCorrect enabled, block swapping locked tiles
      if(mode==="swap" && lockCorrect){
        const numA = tiles[a], numB = tiles[b];
        const lockedA = tileIsCorrectAtIndex(numA, a);
        const lockedB = tileIsCorrectAtIndex(numB, b);
        if(lockedA || lockedB) return false;
      }
      [tiles[a], tiles[b]] = [tiles[b], tiles[a]];
      return true;
    }

    function onTileClick(index){
      if(winOverlay.classList.contains("show")) return;

      if(mode === "slide"){
        // ignore blank clicks
        if(tiles[index] === 0) return;

        if(canSlide(index)){
          startTimerIfNeeded();
          const ok = slideMove(index);
          if(ok){
            incMoves();
            render();
            if(isSolved()) win();
          }else{
            showToast("‚õî Burda olmaz");
          }
        }else{
          // small hint
          showToast("üìå Bo≈ü xananƒ±n yanƒ±nƒ± se√ß");
        }
        return;
      }

      // SWAP mode
      const num = tiles[index];
      if(lockCorrect && tileIsCorrectAtIndex(num, index)){
        showToast("üîí Bu hiss…ô artƒ±q d√ºz yerd…ôdir");
        return;
      }

      if(selectedIndex === null){
        selectedIndex = index;
        render();
        return;
      }

      if(selectedIndex === index){
        selectedIndex = null;
        render();
        return;
      }

      startTimerIfNeeded();
      const ok = swapMove(selectedIndex, index);
      if(!ok){
        showToast("üîí Kilidli hiss…ô var");
        return;
      }

      incMoves();
      selectedIndex = null;
      render();

      if(isSolved()) win();
    }

    /* =========================
       SOLVED CHECK
    ========================== */
    function isSolved(){
      const N = size*size;
      if(mode === "slide"){
        for(let i=0;i<N-1;i++){
          if(tiles[i] !== i+1) return false;
        }
        return tiles[N-1] === 0;
      } else {
        for(let i=0;i<N;i++){
          if(tiles[i] !== i+1) return false;
        }
        return true;
      }
    }

    /* =========================
       WIN UI + CONFETTI
    ========================== */
    const loveLines = [
      "Hiss…ôl…ôr kimi, √ºr…ôkl…ôrimiz d…ô bir-birini tapdƒ± üíò",
      "S…ônl…ô h…ôr ≈üey tamam olur ‚ú®",
      "Bu puzzle kimi‚Ä¶ m…ôn d…ô s…ôni h…ômi≈ü…ô tapƒ±ram üòÑ",
      "∆èn g√∂z…ôl ‚Äòtamamlanma‚Äô ‚Äî s…ôninl…ôdir ‚ù§Ô∏è",
      "G√∂zl…ôrin par√ßalarƒ± birl…ô≈üdirir, q…ôlbin m…ôni üíó"
    ];

    function win(){
      if(timer){ clearInterval(timer); timer = null; }

      const improved = saveRecordIfBest();

      winTime.textContent = formatTime(seconds);
      winMoves.textContent = String(moves);
      winMode.textContent = (mode === "slide") ? `Slide ${size}√ó${size}` : `Swap ${size}√ó${size}`;
      winTitle.textContent = improved ? "YENƒ∞ REKORD! üèÜ" : "AF∆èRƒ∞N ‚ù§Ô∏è";
      winText.textContent = loveLines[Math.floor(Math.random()*loveLines.length)];

      winOverlay.classList.add("show");

      doConfetti();
      showToast("‚úÖ Tamamlandƒ±!");
    }

    function closeWin(){
      winOverlay.classList.remove("show");
    }

    /* Simple confetti (no CDN) */
    const confettiCanvas = $("#confettiCanvas");
    const ctx = confettiCanvas.getContext("2d");
    function resizeConfetti(){
      confettiCanvas.width = window.innerWidth * devicePixelRatio;
      confettiCanvas.height = window.innerHeight * devicePixelRatio;
      confettiCanvas.style.width = window.innerWidth + "px";
      confettiCanvas.style.height = window.innerHeight + "px";
      ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    }
    window.addEventListener("resize", resizeConfetti);
    resizeConfetti();

    function doConfetti(){
      const count = 140;
      const parts = [];
      const W = window.innerWidth;
      const H = window.innerHeight;

      for(let i=0;i<count;i++){
        parts.push({
          x: Math.random()*W,
          y: -20 - Math.random()*H*0.3,
          vx: -1.2 + Math.random()*2.4,
          vy: 2.8 + Math.random()*4.2,
          r: 3 + Math.random()*4,
          rot: Math.random()*Math.PI,
          vr: -0.12 + Math.random()*0.24,
          life: 0,
          ttl: 120 + Math.floor(Math.random()*60),
        });
      }

      let frame = 0;
      function step(){
        frame++;
        ctx.clearRect(0,0,W,H);

        parts.forEach(p=>{
          p.life++;
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.02; // gravity
          p.rot += p.vr;

          const alpha = Math.max(0, 1 - p.life/p.ttl);
          ctx.globalAlpha = alpha;

          // random ‚Äúaccent-ish‚Äù colors without hardcoding palette in CSS
          // (still ok: canvas uses some nice picks)
          const colors = ["#ff2d55","#ff9f0a","#ffd60a","#34c759","#32ade6","#5856d6","#ffffff"];
          ctx.fillStyle = colors[(Math.random()*colors.length)|0];

          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          ctx.fillRect(-p.r, -p.r, p.r*2.1, p.r*1.2);
          ctx.restore();
        });

        ctx.globalAlpha = 1;

        if(frame < 160){
          requestAnimationFrame(step);
        }else{
          ctx.clearRect(0,0,W,H);
        }
      }
      requestAnimationFrame(step);
    }

    /* =========================
       HINT / PREVIEW / IMAGE
    ========================== */
    function showNumbersBrief(){
      const tilesEl = [...grid.querySelectorAll(".tile")];
      tilesEl.forEach(t => t.classList.add("show-num"));
      setTimeout(()=>tilesEl.forEach(t=>t.classList.remove("show-num")), 1200);
    }

    function togglePreview(){
      const show = previewWrap.style.display !== "flex";
      previewWrap.style.display = show ? "flex" : "none";
      if(show){
        previewImg.src = imageUrl;
        showToast("üñºÔ∏è Preview a√ßƒ±ldƒ±");
      }else{
        showToast("ü´• Preview baƒülandƒ±");
      }
    }

    function applyImage(){
      const v = (imgUrlInput.value || "").trim();
      if(!v){
        showToast("Link yapƒ±≈üdƒ±r üôÇ");
        return;
      }
      imageUrl = v;
      localStorage.setItem("puzzleImageUrl", imageUrl);
      previewImg.src = imageUrl;
      shufflePuzzle();
      showToast("‚úÖ ≈û…ôkil yenil…ôndi");
    }

    /* =========================
       INPUT: keyboard & swipe (slide)
    ========================== */
    function handleArrow(key){
      if(mode !== "slide") return;
      if(winOverlay.classList.contains("show")) return;

      const blank = tiles.indexOf(0);
      const r = Math.floor(blank/size);
      const c = blank%size;

      // Arrow keys should move tiles into blank:
      // If ArrowLeft -> we want blank to move left => tile from left moves into blank => blank swaps with blank-1
      let target = null;
      if(key === "ArrowLeft" && c < size-1) target = blank + 1;
      if(key === "ArrowRight" && c > 0) target = blank - 1;
      if(key === "ArrowUp" && r < size-1) target = blank + size;
      if(key === "ArrowDown" && r > 0) target = blank - size;

      if(target !== null){
        startTimerIfNeeded();
        const ok = slideMove(target);
        if(ok){
          incMoves();
          render();
          if(isSolved()) win();
        }
      }
    }

    document.addEventListener("keydown", (e)=>{
      if(["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"].includes(e.key)){
        e.preventDefault();
        handleArrow(e.key);
      }
    });

    // Swipe on board (slide mode)
    let touchStartX = 0, touchStartY = 0, touching = false;
    grid.addEventListener("touchstart", (e)=>{
      if(mode !== "slide") return;
      if(e.touches.length !== 1) return;
      touching = true;
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }, {passive:true});

    grid.addEventListener("touchend", (e)=>{
      if(mode !== "slide") return;
      if(!touching) return;
      touching = false;

      const endX = (e.changedTouches[0] || {}).clientX;
      const endY = (e.changedTouches[0] || {}).clientY;
      const dx = endX - touchStartX;
      const dy = endY - touchStartY;

      const absX = Math.abs(dx);
      const absY = Math.abs(dy);
      if(Math.max(absX, absY) < 28) return; // ignore tiny swipes

      // Determine direction: swipe should move blank opposite to finger direction feel:
      // if swipe left -> we treat as ArrowLeft
      if(absX > absY){
        handleArrow(dx < 0 ? "ArrowLeft" : "ArrowRight");
      }else{
        handleArrow(dy < 0 ? "ArrowUp" : "ArrowDown");
      }
    }, {passive:true});

    /* =========================
       BUTTONS / EVENTS
    ========================== */
    modeSlideBtn.addEventListener("click", ()=>{
      mode = "slide";
      localStorage.setItem("puzzleMode", mode);
      setModeUI();
      shufflePuzzle();
    });
    modeSwapBtn.addEventListener("click", ()=>{
      mode = "swap";
      localStorage.setItem("puzzleMode", mode);
      setModeUI();
      shufflePuzzle();
    });

    sizeSelect.value = String(size);
    sizeSelect.addEventListener("change", ()=>{
      const v = parseInt(sizeSelect.value, 10);
      size = [3,4,5].includes(v) ? v : 4;
      localStorage.setItem("puzzleSize", String(size));
      setGridCss();
      shufflePuzzle();
    });

    shuffleBtn.addEventListener("click", shufflePuzzle);
    hintBtn.addEventListener("click", ()=>{
      showNumbersBrief();
      showToast("üëÄ R…ôq…ôml…ôr g√∂r√ºnd√º");
    });
    previewBtn.addEventListener("click", togglePreview);

    imgUrlInput.value = imageUrl;
    applyImgBtn.addEventListener("click", applyImage);

    lockToggle.addEventListener("click", ()=>{
      lockCorrect = !lockCorrect;
      localStorage.setItem("puzzleLockCorrect", lockCorrect ? "true" : "false");
      lockToggle.classList.toggle("on", lockCorrect);
      render();
      showToast(lockCorrect ? "üîí Kilid aktiv" : "üîì Kilid s√∂nd√º");
    });

    resetBestBtn.addEventListener("click", ()=>{
      const tKey = recKey("bestTime");
      const mKey = recKey("bestMoves");
      localStorage.removeItem(tKey);
      localStorage.removeItem(mKey);
      loadRecords();
      showToast("üßº Rekordlar sƒ±fƒ±rlandƒ±");
    });

    playAgainBtn.addEventListener("click", shufflePuzzle);
    closeWinBtn.addEventListener("click", closeWin);
    winOverlay.addEventListener("click", (e)=>{
      if(e.target === winOverlay) closeWin();
    });

    /* =========================
       INIT
    ========================== */
    function init(){
      setModeUI();
      setGridCss();
      previewImg.src = imageUrl;
      shufflePuzzle();
      loadRecords();
    }
    init();
  </script>
</body>
</html>
